<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>가위바위보게임</title>
    <style>
        #computer{
            width: 142px;
            height: 200px;
        }
    </style>
</head>
<body>
    <div id="computer">
    </div>
    <div>
        <button id='scissors' class='btn'>가위</button>
        <button id='rock' class='btn'>바위</button>
        <button id='paper' class='btn'>보</button>
        
    </div>
    <div id="score"></div>
    <script>
        const $computer = document.querySelector('#computer');
        const $score = document.querySelector('#score');
        const $rock = document.querySelector('#rock');
        const $scissors = document.querySelector('#scissors');
        const $paper = document.querySelector('#paper');
        // 상대경로 <-> 절대경로
        // 상대경로 : . , .. 으로 시작하는 경로 
        //          기준 - 현재 소스코드의 경로
        //                가위바위보.html이 있는 경로
        //         .  : 현재위치 --> 가위바위보.html이 있는 경로
        //         .. : 현재위치의 부모 경로
        //              가위바위보.html이 있는 경로의 부모경로
        //              ~~\js\가위바위보
        //              ../../test.png
        // 절대경로 : C:\ , D:\, /
        const IMG_URL = './rsp.png';//rsp.png를 불러오는 함수
        
//        $computer.style.background = `url(${IMG_URL}) -220px 0`; // 바위
//        const rspX = '-440px';
//        const scissorsX = rspX;
//        const rockX = rspX;
//        const paperX = rspX;
//        $computer.style.background = `url(${IMG_URL}) ${rspX} 0`; // 보
        
//        
        // 관련된 정보는 객체로 묶어 처리하자.
        
        // 객체정의는 중괄호 이용.
        const rspX = {
            scissors : '0',
            rock : '-220px',
            paper : '-440px'
        };
        // 객체의 속성사용법
        // 1. 객체명.속성명
        // 2. 객체명['속성명'] <- 연관배열형 접근법
        let computerChoice = 'scissors';
        // == rsx{computerChoice}
        
        // setTimeout(비동기콜백함수,밀리초단위값);
        const changeComputerHand = () => {
            if (computerChoice === 'rock') { // 바위면
              computerChoice = 'scissors';
            } else if (computerChoice === 'scissors') { // 가위면
              computerChoice = 'paper';
            } else if (computerChoice === 'paper') { // 보면
              computerChoice = 'rock';
            }
            $computer.style.background = `url(${IMG_URL}) ${rspX[computerChoice]} 0`;
            $computer.style.backgroundSize = 'auto 200px';
        }
                   
                   
        
        
        let intervalId = setInterval(changeComputerHand,50)
        
//        const clickButton = () => {
//            clearInterval(intervalId);
//            // 점수 계산 및 화면 표시
//            setTimeout(() => {
//                clearInterval(intervalId)
//                intervalId = setInterval(changeComputerHand,50);
//            },1000);
//        };
        const clickable = true;
        let clickButton () => {
            if (clickable){
                clearInterval(intervalId);
                clickable = false;
                setTimeout(() => {
                    clickable = true;
                    intervalId = setInterval(changeComputerHand,50);
                }, 1000)
            }
        }
        $rock.addEventListener('click',clickButton);
        $scissors.addEventListener('click',clickButton);
        $paper.addEventListener('click',clickButton);
        
        let 
        
        
        
        // setTimeout()
        // 일회성
        // setInterval(비동기콜백한수 , 밀리초단위초) 간격을 설정한다.
        // 다회성
            
// 타이머 멈추기
// 타이머 ID를 활용
// setTimeout(), setInterval() 반환값
// 타이머 ID를 반환
// let 타이머 ID변수 = setTimeout();
// let 타이머ID변수 = setInterval();
// 필요시
// clearTimeout(타이머ID변수);
// clearInterval(타이머ID변수);
// 여기서 setTimeout은 코드가 끝나고 1초후에 실행함.
        
//        setInterval(() => {
//            console.log('hello');
//        }, 1000)
//        
//        바꾸면
//        funtion hello(){
//            console.log('hello')
//            setTimeout(hello,1000);
//        }
//        setTimeout(hello,1000)
    </script>
</body>
</html>